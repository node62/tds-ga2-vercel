import os
from fastapi import FastAPI, Query
from fastapi.middleware.cors import CORSMiddleware
import json

# Construct an absolute path to marks.json relative to this file's location
# This is important for Vercel's environment
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MARKS_FILE_PATH = os.path.join(BASE_DIR, "marks.json")

# Load the marks data
try:
    with open(MARKS_FILE_PATH, "r") as f:
        marks_data = json.load(f) # marks_data will be a list of dicts
except FileNotFoundError:
    # This error will be raised if marks.json is not found where expected
    raise RuntimeError(f"Could not find marks.json at {MARKS_FILE_PATH}. Ensure it's in the same directory as main.py and deployed with your Vercel app.")
except json.JSONDecodeError:
    raise RuntimeError(f"Could not decode marks.json at {MARKS_FILE_PATH}. Check if it's a valid JSON.")


app = FastAPI()

# Enable CORS to allow GET requests from any origin
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["GET"], # Allows only GET requests
    allow_headers=["*"],  # Allows all headers
)

@app.get("/")
async def read_root():
    return {"message": "Welcome! Use the /api endpoint to fetch marks. e.g., /api?name=student_name"}

@app.get("/api")
async def get_marks(name: list[str] = Query(..., title="Student Names", description="A list of student names to fetch marks for.")):
    """
    Retrieves the marks for a list of specified student names.
    The marks are returned in the same order as the input names.
    If a student name is not found, their mark will not be included in the output list.
    """
    student_marks_values = []
    if not isinstance(marks_data, list):
        # This case should ideally not be hit if marks.json is loaded correctly as a list of dicts
        # but it's a good safeguard or place for more specific error handling.
        return {"error": "Marks data is not in the expected format (list of students)."}

    for n_val in name:
        found_student = None
        for student_record in marks_data:
            if student_record.get("name") == n_val:
                found_student = student_record
                break
        
        if found_student:
            student_marks_values.append(found_student['marks'])
        # If a student is not found, their mark is simply not added to the list,
        # which matches the behavior implied by the example {"marks": [10, 20]}
        # where only found marks are returned.

    return {"marks": student_marks_values}
